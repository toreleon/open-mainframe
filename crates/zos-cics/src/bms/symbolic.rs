//! Symbolic map generator for COBOL.
//!
//! Generates COBOL copybooks for BMS maps.

use super::field::BmsField;
use super::parser::{BmsMap, BmsMapset};

/// Symbolic map generator.
pub struct SymbolicMapGenerator {
    /// Include length fields
    include_length: bool,
    /// Include attribute fields
    include_attribute: bool,
    /// Include flag fields
    include_flag: bool,
}

impl SymbolicMapGenerator {
    /// Create a new generator.
    pub fn new() -> Self {
        Self {
            include_length: true,
            include_attribute: true,
            include_flag: true,
        }
    }

    /// Disable length fields.
    pub fn without_length(mut self) -> Self {
        self.include_length = false;
        self
    }

    /// Disable attribute fields.
    pub fn without_attribute(mut self) -> Self {
        self.include_attribute = false;
        self
    }

    /// Generate COBOL copybook for a mapset.
    pub fn generate(&self, mapset: &BmsMapset) -> String {
        let mut output = String::new();

        // Header comment
        output.push_str("      ******************************************************************\n");
        output.push_str(&format!(
            "      * SYMBOLIC MAP FOR MAPSET: {}\n",
            mapset.name
        ));
        output.push_str("      * GENERATED BY ZOS-CLONE BMS PROCESSOR\n");
        output.push_str("      ******************************************************************\n");
        output.push('\n');

        // Generate input map
        output.push_str(&self.generate_input_map(mapset));
        output.push('\n');

        // Generate output map
        output.push_str(&self.generate_output_map(mapset));

        output
    }

    fn generate_input_map(&self, mapset: &BmsMapset) -> String {
        let mut output = String::new();

        output.push_str(&format!(
            "       01  {}I.\n",
            mapset.name
        ));

        for map in &mapset.maps {
            output.push_str(&format!(
                "           05  {}I.\n",
                map.name
            ));

            // TIOAPFX
            output.push_str("               10  FILLER             PIC X(12).\n");

            for field in &map.fields {
                if !field.name.is_empty() {
                    output.push_str(&self.generate_input_field(field));
                }
            }
        }

        output
    }

    fn generate_output_map(&self, mapset: &BmsMapset) -> String {
        let mut output = String::new();

        output.push_str(&format!(
            "       01  {}O REDEFINES {}I.\n",
            mapset.name, mapset.name
        ));

        for map in &mapset.maps {
            output.push_str(&format!(
                "           05  {}O.\n",
                map.name
            ));

            // TIOAPFX
            output.push_str("               10  FILLER             PIC X(12).\n");

            for field in &map.fields {
                if !field.name.is_empty() {
                    output.push_str(&self.generate_output_field(field));
                }
            }
        }

        output
    }

    fn generate_input_field(&self, field: &BmsField) -> String {
        let mut output = String::new();
        let name = field.name.replace('-', "_");

        // Length field
        if self.include_length {
            output.push_str(&format!(
                "               10  {}L              PIC S9(4) COMP.\n",
                name
            ));
        }

        // Flag field
        if self.include_flag {
            output.push_str(&format!(
                "               10  {}F              PIC X.\n",
                name
            ));
        }

        // Attribute field
        if self.include_attribute {
            output.push_str(&format!(
                "               10  {}A              PIC X.\n",
                name
            ));
        }

        // Data field
        let picture = self.get_picture(field);
        output.push_str(&format!(
            "               10  {}I              PIC {}.\n",
            name, picture
        ));

        output
    }

    fn generate_output_field(&self, field: &BmsField) -> String {
        let mut output = String::new();
        let name = field.name.replace('-', "_");

        // Length field
        if self.include_length {
            output.push_str(&format!(
                "               10  {}L              PIC S9(4) COMP.\n",
                name
            ));
        }

        // Flag field
        if self.include_flag {
            output.push_str(&format!(
                "               10  {}F              PIC X.\n",
                name
            ));
        }

        // Attribute field
        if self.include_attribute {
            output.push_str(&format!(
                "               10  {}A              PIC X.\n",
                name
            ));
        }

        // Data field
        let picture = self.get_picture(field);
        output.push_str(&format!(
            "               10  {}O              PIC {}.\n",
            name, picture
        ));

        output
    }

    fn get_picture(&self, field: &BmsField) -> String {
        // Use explicit picture if provided
        if let Some(pic) = &field.picture {
            return pic.clone();
        }

        // Generate default picture based on field type and length
        if field.attributes.numeric {
            if field.length > 9 {
                format!("9({})", field.length)
            } else {
                "9".repeat(field.length)
            }
        } else if field.length > 10 {
            format!("X({})", field.length)
        } else {
            "X".repeat(field.length)
        }
    }

    /// Generate DFHBMSCA (attribute byte constants).
    pub fn generate_dfhbmsca() -> String {
        let mut output = String::new();

        output.push_str("      ******************************************************************\n");
        output.push_str("      * DFHBMSCA - BMS ATTRIBUTE CONSTANTS\n");
        output.push_str("      ******************************************************************\n");
        output.push_str("       01  DFHBMSCA.\n");
        output.push_str("           05  DFHBMPEM          PIC X VALUE X'00'.\n");
        output.push_str("           05  DFHBMPNL          PIC X VALUE X'00'.\n");
        output.push_str("           05  DFHBMASK          PIC X VALUE X'71'.\n");
        output.push_str("           05  DFHBMUNP          PIC X VALUE X'40'.\n");
        output.push_str("           05  DFHBMUNN          PIC X VALUE X'50'.\n");
        output.push_str("           05  DFHBMPRO          PIC X VALUE X'60'.\n");
        output.push_str("           05  DFHBMPRF          PIC X VALUE X'61'.\n");
        output.push_str("           05  DFHBMBRY          PIC X VALUE X'68'.\n");
        output.push_str("           05  DFHBMDAR          PIC X VALUE X'6C'.\n");
        output.push_str("           05  DFHBMFSE          PIC X VALUE X'41'.\n");
        output.push_str("           05  DFHSA             PIC X VALUE X'28'.\n");
        output.push_str("           05  DFHCOLOR          PIC X VALUE X'42'.\n");
        output.push_str("           05  DFHPS             PIC X VALUE X'43'.\n");
        output.push_str("           05  DFHHLT            PIC X VALUE X'41'.\n");
        output.push_str("           05  DFHDFCOL          PIC X VALUE X'00'.\n");
        output.push_str("           05  DFHBLUE           PIC X VALUE X'F1'.\n");
        output.push_str("           05  DFHRED            PIC X VALUE X'F2'.\n");
        output.push_str("           05  DFHPINK           PIC X VALUE X'F3'.\n");
        output.push_str("           05  DFHGREEN          PIC X VALUE X'F4'.\n");
        output.push_str("           05  DFHTURQ           PIC X VALUE X'F5'.\n");
        output.push_str("           05  DFHYELLO          PIC X VALUE X'F6'.\n");
        output.push_str("           05  DFHWHITE          PIC X VALUE X'F7'.\n");
        output.push_str("           05  DFHDFHI           PIC X VALUE X'00'.\n");
        output.push_str("           05  DFHBLINK          PIC X VALUE X'F1'.\n");
        output.push_str("           05  DFHREVRS          PIC X VALUE X'F2'.\n");
        output.push_str("           05  DFHUNDLN          PIC X VALUE X'F4'.\n");

        output
    }
}

impl Default for SymbolicMapGenerator {
    fn default() -> Self {
        Self::new()
    }
}

/// Calculate symbolic map structure size.
pub fn calculate_map_size(map: &BmsMap, include_length: bool, include_flag: bool, include_attr: bool) -> usize {
    let mut size = 12; // TIOAPFX

    for field in &map.fields {
        if !field.name.is_empty() {
            if include_length {
                size += 2; // S9(4) COMP
            }
            if include_flag {
                size += 1;
            }
            if include_attr {
                size += 1;
            }
            size += field.length;
        }
    }

    size
}

/// Decompose a raw FROM data buffer into individual BMS field values.
///
/// When a COBOL program issues `SEND MAP FROM(data-area)`, the data area
/// is a structured buffer matching the symbolic map layout (generated by
/// [`SymbolicMapGenerator`]). Each named BMS field occupies a fixed-size
/// slot: optional L (2 bytes), F (1 byte), A (1 byte), then the data field.
///
/// This function parses that layout and returns a `HashMap` keyed by BMS
/// field name, with the data portion as the value. Fields whose length
/// byte is zero (meaning the program didn't modify them) are skipped.
pub fn decompose_from_buffer(
    map: &BmsMap,
    buffer: &[u8],
) -> std::collections::HashMap<String, Vec<u8>> {
    use std::collections::HashMap;

    let mut result = HashMap::new();
    // Standard symbolic map layout: TIOAPFX (12 bytes) then L/F/A/data per field
    let mut offset = 12;

    for field in &map.fields {
        if field.name.is_empty() {
            continue;
        }

        // L field: 2-byte signed binary (S9(4) COMP)
        let field_len = if offset + 2 <= buffer.len() {
            let hi = buffer[offset] as i16;
            let lo = buffer[offset + 1] as i16;
            let len = (hi << 8) | lo;
            offset += 2;
            len.max(0) as usize
        } else {
            offset += 2;
            0
        };

        // F field: 1 byte (flag)
        if offset < buffer.len() {
            offset += 1;
        } else {
            offset += 1;
        }

        // A field: 1 byte (attribute)
        if offset < buffer.len() {
            offset += 1;
        } else {
            offset += 1;
        }

        // Data field: field.length bytes
        let data_start = offset;
        let data_end = (offset + field.length).min(buffer.len());
        offset += field.length;

        // Only include the field if it has a non-zero length indicator,
        // or if the data portion contains non-space/non-null content.
        // A zero-length indicator means the program didn't set this field.
        if field_len > 0 || data_start < buffer.len() {
            let data = if data_start < buffer.len() {
                buffer[data_start..data_end].to_vec()
            } else {
                vec![b' '; field.length]
            };
            // Only include if there's actual content (not all nulls).
            // When field_len > 0, the program explicitly set this field.
            if field_len > 0 || data.iter().any(|&b| b != 0) {
                result.insert(field.name.clone(), data);
            }
        }
    }

    result
}

/// Decompose a raw FROM buffer as a COBOL display string.
///
/// This is a simpler alternative to [`decompose_from_buffer`] that handles
/// the case where the COBOL interpreter passes FROM data as a display string
/// (character representation) rather than raw binary. In this mode, each
/// field's data is extracted positionally from the string based on the
/// symbolic map's field order and lengths.
pub fn decompose_from_display_string(
    map: &BmsMap,
    display_str: &str,
) -> std::collections::HashMap<String, Vec<u8>> {
    use std::collections::HashMap;

    let mut result = HashMap::new();
    let bytes = display_str.as_bytes();

    // In display-string mode, the COBOL interpreter stores the symbolic map
    // as a flat string. We iterate fields and extract by offset.
    // Layout: 12 chars TIOAPFX + (4 chars L/F/A + data) per field
    let mut offset = 12;

    for field in &map.fields {
        if field.name.is_empty() {
            continue;
        }

        // L: 2 display chars, F: 1 char, A: 1 char
        offset += 4;

        // Data field
        let data_start = offset;
        let data_end = (offset + field.length).min(bytes.len());
        offset += field.length;

        if data_start < bytes.len() {
            let data = bytes[data_start..data_end].to_vec();
            // Only include if non-empty (not all spaces)
            if data.iter().any(|&b| b != b' ' && b != 0) {
                result.insert(field.name.clone(), data);
            }
        }
    }

    result
}

/// Compose individual BMS field values into a symbolic map display string.
///
/// This is the reverse of [`decompose_from_display_string`]. It takes a
/// `HashMap` of field name â†’ data values and produces a flat string that
/// matches the symbolic map layout: 12 chars TIOAPFX, then for each named
/// field: 2 chars L (length as 2-digit decimal, zero-padded), 1 char F
/// (flag), 1 char A (attribute), then `field.length` chars of data
/// (right-padded with spaces).
///
/// This is used by RECEIVE MAP to compose the collected TUI input fields
/// back into the format a COBOL program expects in its `INTO` data area.
pub fn compose_to_display_string(
    map: &BmsMap,
    fields: &std::collections::HashMap<String, Vec<u8>>,
) -> String {
    let size = calculate_map_size(map, true, true, true);
    let mut buffer = vec![b' '; size];

    // TIOAPFX: 12 spaces (already initialized)
    let mut offset = 12;

    for field in &map.fields {
        if field.name.is_empty() {
            continue;
        }

        let data = fields.get(&field.name);
        let data_len = data.map(|d| d.len().min(field.length)).unwrap_or(0);

        // L field: 2 characters representing data length (zero-padded decimal)
        if offset + 2 <= buffer.len() {
            let len_str = format!("{:02}", data_len.min(99));
            buffer[offset] = len_str.as_bytes()[0];
            buffer[offset + 1] = len_str.as_bytes()[1];
        }
        offset += 2;

        // F field: 1 byte flag (space = no flags)
        offset += 1;

        // A field: 1 byte attribute (space = default)
        offset += 1;

        // Data field: field.length bytes, right-padded with spaces
        if let Some(d) = data {
            let copy_len = d.len().min(field.length);
            if offset + copy_len <= buffer.len() {
                buffer[offset..offset + copy_len].copy_from_slice(&d[..copy_len]);
            }
        }
        offset += field.length;
    }

    String::from_utf8_lossy(&buffer).to_string()
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::bms::parser::BmsParser;

    #[test]
    fn test_generate_symbolic_map() {
        let source = r#"
CUSTMAP  DFHMSD TYPE=MAP,LANG=COBOL
CUSTM1   DFHMDI SIZE=(24,80)
CUSTNO   DFHMDF POS=(5,15),LENGTH=8,ATTRB=(NUM,UNPROT)
CUSTNM   DFHMDF POS=(5,25),LENGTH=30,ATTRB=(PROT)
         DFHMSD TYPE=FINAL
"#;

        let mut parser = BmsParser::new();
        let mapset = parser.parse(source).unwrap();

        let generator = SymbolicMapGenerator::new();
        let copybook = generator.generate(&mapset);

        // Check structure
        assert!(copybook.contains("01  CUSTMAPI."));
        assert!(copybook.contains("05  CUSTM1I."));
        assert!(copybook.contains("CUSTNOL"));
        assert!(copybook.contains("CUSTNOI"));
        assert!(copybook.contains("01  CUSTMAPO REDEFINES CUSTMAPI."));
    }

    #[test]
    fn test_picture_generation() {
        let source = r#"
TEST     DFHMSD TYPE=MAP,LANG=COBOL
TESTM    DFHMDI SIZE=(24,80)
SHORT    DFHMDF POS=(1,1),LENGTH=5,ATTRB=(UNPROT)
LONG     DFHMDF POS=(2,1),LENGTH=50,ATTRB=(UNPROT)
NUMER    DFHMDF POS=(3,1),LENGTH=8,ATTRB=(NUM,UNPROT)
         DFHMSD TYPE=FINAL
"#;

        let mut parser = BmsParser::new();
        let mapset = parser.parse(source).unwrap();

        let generator = SymbolicMapGenerator::new();
        let copybook = generator.generate(&mapset);

        // Short alphanumeric should use XXXXX
        assert!(copybook.contains("PIC XXXXX"));
        // Long alphanumeric should use X(50)
        assert!(copybook.contains("PIC X(50)"));
        // Numeric should use 9s
        assert!(copybook.contains("PIC 99999999"));
    }

    #[test]
    fn test_dfhbmsca() {
        let dfhbmsca = SymbolicMapGenerator::generate_dfhbmsca();

        assert!(dfhbmsca.contains("DFHBMSCA"));
        assert!(dfhbmsca.contains("DFHBMASK"));
        assert!(dfhbmsca.contains("DFHBMPRO"));
        assert!(dfhbmsca.contains("DFHGREEN"));
    }

    #[test]
    fn test_map_size_calculation() {
        let source = r#"
TEST     DFHMSD TYPE=MAP,LANG=COBOL
TESTM    DFHMDI SIZE=(24,80)
FLD1     DFHMDF POS=(1,1),LENGTH=10,ATTRB=(UNPROT)
FLD2     DFHMDF POS=(2,1),LENGTH=20,ATTRB=(PROT)
         DFHMSD TYPE=FINAL
"#;

        let mut parser = BmsParser::new();
        let mapset = parser.parse(source).unwrap();
        let map = &mapset.maps[0];

        // Size = 12 (TIOAPFX) + 2 fields * (2 + 1 + 1 + length)
        // = 12 + (2 + 1 + 1 + 10) + (2 + 1 + 1 + 20)
        // = 12 + 14 + 24 = 50
        let size = calculate_map_size(map, true, true, true);
        assert_eq!(size, 50);
    }

    #[test]
    fn test_decompose_from_buffer() {
        let source = r#"
TEST     DFHMSD TYPE=MAP,LANG=COBOL
TESTM    DFHMDI SIZE=(24,80)
FLD1     DFHMDF POS=(1,1),LENGTH=10,ATTRB=(UNPROT)
FLD2     DFHMDF POS=(2,1),LENGTH=5,ATTRB=(UNPROT)
         DFHMSD TYPE=FINAL
"#;
        let mut parser = BmsParser::new();
        let mapset = parser.parse(source).unwrap();
        let map = &mapset.maps[0];

        // Symbolic map layout:
        // 12 bytes TIOAPFX
        // FLD1: 2 L + 1 F + 1 A + 10 data = 14 bytes (offsets 12..26)
        // FLD2: 2 L + 1 F + 1 A + 5 data = 9 bytes (offsets 26..35)
        // Total = 35 bytes
        let size = super::calculate_map_size(map, true, true, true);
        assert_eq!(size, 35);
        let mut buffer = vec![0u8; size];

        // FLD1: L=5 (only 5 chars of data are meaningful)
        buffer[12] = 0; // high byte of length
        buffer[13] = 5; // low byte of length
        // F=0 at [14], A=0 at [15]
        // Data starts at offset 16, length 10
        buffer[16..21].copy_from_slice(b"Hello");

        // FLD2: L=3, starts at offset 26
        buffer[26] = 0;
        buffer[27] = 3;
        // F=0 at [28], A=0 at [29]
        // Data starts at offset 30, length 5
        buffer[30..33].copy_from_slice(b"Hi!");

        let result = super::decompose_from_buffer(map, &buffer);
        assert!(result.contains_key("FLD1"), "FLD1 should be present");
        assert!(result.contains_key("FLD2"), "FLD2 should be present");

        let fld1 = &result["FLD1"];
        assert!(
            String::from_utf8_lossy(fld1).starts_with("Hello"),
            "FLD1 should start with 'Hello', got '{}'",
            String::from_utf8_lossy(fld1)
        );

        let fld2 = &result["FLD2"];
        assert!(
            String::from_utf8_lossy(fld2).starts_with("Hi!"),
            "FLD2 should start with 'Hi!', got '{}'",
            String::from_utf8_lossy(fld2)
        );
    }

    #[test]
    fn test_decompose_from_buffer_skips_zero_length_fields() {
        let source = r#"
TEST     DFHMSD TYPE=MAP,LANG=COBOL
TESTM    DFHMDI SIZE=(24,80)
FLD1     DFHMDF POS=(1,1),LENGTH=10,ATTRB=(UNPROT)
FLD2     DFHMDF POS=(2,1),LENGTH=5,ATTRB=(UNPROT)
         DFHMSD TYPE=FINAL
"#;
        let mut parser = BmsParser::new();
        let mapset = parser.parse(source).unwrap();
        let map = &mapset.maps[0];

        // Build a buffer where FLD1 has data but FLD2 is all zeros
        let size = super::calculate_map_size(map, true, true, true);
        let mut buffer = vec![0u8; size];
        buffer[12] = 0;
        buffer[13] = 5; // FLD1 length = 5
        buffer[16..21].copy_from_slice(b"Hello");
        // FLD2: L=0, all zeros -> should be skipped

        let result = super::decompose_from_buffer(map, &buffer);
        assert!(result.contains_key("FLD1"), "FLD1 should be present");
        assert!(!result.contains_key("FLD2"), "FLD2 should be skipped (zero length, zero data)");
    }

    #[test]
    fn test_decompose_from_display_string() {
        let source = r#"
TEST     DFHMSD TYPE=MAP,LANG=COBOL
TESTM    DFHMDI SIZE=(24,80)
FLD1     DFHMDF POS=(1,1),LENGTH=10,ATTRB=(UNPROT)
FLD2     DFHMDF POS=(2,1),LENGTH=5,ATTRB=(UNPROT)
         DFHMSD TYPE=FINAL
"#;
        let mut parser = BmsParser::new();
        let mapset = parser.parse(source).unwrap();
        let map = &mapset.maps[0];

        // Build a display string: 12 chars TIOAPFX + 4 chars (L/F/A) + 10 data + 4 + 5 data = 35
        let mut display = String::new();
        display.push_str("            "); // 12 TIOAPFX
        display.push_str("    "); // L/F/A for FLD1
        display.push_str("Hello     "); // 10 chars for FLD1
        display.push_str("    "); // L/F/A for FLD2
        display.push_str("World"); // 5 chars for FLD2

        let result = super::decompose_from_display_string(map, &display);
        assert!(result.contains_key("FLD1"));
        assert!(result.contains_key("FLD2"));

        let fld1 = String::from_utf8_lossy(&result["FLD1"]);
        assert!(fld1.starts_with("Hello"), "FLD1 = '{}'", fld1);

        let fld2 = String::from_utf8_lossy(&result["FLD2"]);
        assert_eq!(fld2.trim(), "World");
    }

    #[test]
    fn test_compose_to_display_string() {
        let source = r#"
TEST     DFHMSD TYPE=MAP,LANG=COBOL
TESTM    DFHMDI SIZE=(24,80)
FLD1     DFHMDF POS=(1,1),LENGTH=10,ATTRB=(UNPROT)
FLD2     DFHMDF POS=(2,1),LENGTH=5,ATTRB=(UNPROT)
         DFHMSD TYPE=FINAL
"#;
        let mut parser = BmsParser::new();
        let mapset = parser.parse(source).unwrap();
        let map = &mapset.maps[0];

        let mut fields = std::collections::HashMap::new();
        fields.insert("FLD1".to_string(), b"Hello".to_vec());
        fields.insert("FLD2".to_string(), b"World".to_vec());

        let result = super::compose_to_display_string(map, &fields);

        // Total size = 12 + (2+1+1+10) + (2+1+1+5) = 35
        assert_eq!(result.len(), 35, "Composed string should be 35 chars");

        // Decompose it back and verify round-trip
        let decomposed = super::decompose_from_display_string(map, &result);
        assert!(decomposed.contains_key("FLD1"));
        assert!(decomposed.contains_key("FLD2"));

        let fld1 = String::from_utf8_lossy(&decomposed["FLD1"]);
        assert!(fld1.starts_with("Hello"), "FLD1 = '{}'", fld1);

        let fld2 = String::from_utf8_lossy(&decomposed["FLD2"]);
        assert_eq!(fld2.trim(), "World");
    }

    #[test]
    fn test_compose_round_trip_empty_fields() {
        let source = r#"
TEST     DFHMSD TYPE=MAP,LANG=COBOL
TESTM    DFHMDI SIZE=(24,80)
FLD1     DFHMDF POS=(1,1),LENGTH=8,ATTRB=(UNPROT)
FLD2     DFHMDF POS=(2,1),LENGTH=8,ATTRB=(UNPROT)
         DFHMSD TYPE=FINAL
"#;
        let mut parser = BmsParser::new();
        let mapset = parser.parse(source).unwrap();
        let map = &mapset.maps[0];

        // Only FLD1 has data, FLD2 is not present
        let mut fields = std::collections::HashMap::new();
        fields.insert("FLD1".to_string(), b"ADMIN".to_vec());

        let composed = super::compose_to_display_string(map, &fields);

        // Decompose back
        let decomposed = super::decompose_from_display_string(map, &composed);
        assert!(decomposed.contains_key("FLD1"));
        assert!(!decomposed.contains_key("FLD2"), "FLD2 should be absent (all spaces)");

        let fld1 = String::from_utf8_lossy(&decomposed["FLD1"]);
        assert!(fld1.starts_with("ADMIN"), "FLD1 = '{}'", fld1);
    }

    #[test]
    fn test_without_optional_fields() {
        let source = r#"
TEST     DFHMSD TYPE=MAP,LANG=COBOL
TESTM    DFHMDI SIZE=(24,80)
FLD1     DFHMDF POS=(1,1),LENGTH=10,ATTRB=(UNPROT)
         DFHMSD TYPE=FINAL
"#;

        let mut parser = BmsParser::new();
        let mapset = parser.parse(source).unwrap();

        let generator = SymbolicMapGenerator::new()
            .without_length()
            .without_attribute();

        let copybook = generator.generate(&mapset);

        // Should not contain length field
        assert!(!copybook.contains("FLD1L"));
        // Should not contain attribute field
        assert!(!copybook.contains("FLD1A"));
        // Should still contain data field
        assert!(copybook.contains("FLD1I"));
    }
}
