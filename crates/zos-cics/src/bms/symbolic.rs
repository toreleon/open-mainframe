//! Symbolic map generator for COBOL.
//!
//! Generates COBOL copybooks for BMS maps.

use super::field::BmsField;
use super::parser::{BmsMap, BmsMapset};

/// Symbolic map generator.
pub struct SymbolicMapGenerator {
    /// Include length fields
    include_length: bool,
    /// Include attribute fields
    include_attribute: bool,
    /// Include flag fields
    include_flag: bool,
}

impl SymbolicMapGenerator {
    /// Create a new generator.
    pub fn new() -> Self {
        Self {
            include_length: true,
            include_attribute: true,
            include_flag: true,
        }
    }

    /// Disable length fields.
    pub fn without_length(mut self) -> Self {
        self.include_length = false;
        self
    }

    /// Disable attribute fields.
    pub fn without_attribute(mut self) -> Self {
        self.include_attribute = false;
        self
    }

    /// Generate COBOL copybook for a mapset.
    pub fn generate(&self, mapset: &BmsMapset) -> String {
        let mut output = String::new();

        // Header comment
        output.push_str("      ******************************************************************\n");
        output.push_str(&format!(
            "      * SYMBOLIC MAP FOR MAPSET: {}\n",
            mapset.name
        ));
        output.push_str("      * GENERATED BY ZOS-CLONE BMS PROCESSOR\n");
        output.push_str("      ******************************************************************\n");
        output.push('\n');

        // Generate input map
        output.push_str(&self.generate_input_map(mapset));
        output.push('\n');

        // Generate output map
        output.push_str(&self.generate_output_map(mapset));

        output
    }

    fn generate_input_map(&self, mapset: &BmsMapset) -> String {
        let mut output = String::new();

        output.push_str(&format!(
            "       01  {}I.\n",
            mapset.name
        ));

        for map in &mapset.maps {
            output.push_str(&format!(
                "           05  {}I.\n",
                map.name
            ));

            // TIOAPFX
            output.push_str("               10  FILLER             PIC X(12).\n");

            for field in &map.fields {
                if !field.name.is_empty() {
                    output.push_str(&self.generate_input_field(field));
                }
            }
        }

        output
    }

    fn generate_output_map(&self, mapset: &BmsMapset) -> String {
        let mut output = String::new();

        output.push_str(&format!(
            "       01  {}O REDEFINES {}I.\n",
            mapset.name, mapset.name
        ));

        for map in &mapset.maps {
            output.push_str(&format!(
                "           05  {}O.\n",
                map.name
            ));

            // TIOAPFX
            output.push_str("               10  FILLER             PIC X(12).\n");

            for field in &map.fields {
                if !field.name.is_empty() {
                    output.push_str(&self.generate_output_field(field));
                }
            }
        }

        output
    }

    fn generate_input_field(&self, field: &BmsField) -> String {
        let mut output = String::new();
        let name = field.name.replace('-', "_");

        // Length field
        if self.include_length {
            output.push_str(&format!(
                "               10  {}L              PIC S9(4) COMP.\n",
                name
            ));
        }

        // Flag field
        if self.include_flag {
            output.push_str(&format!(
                "               10  {}F              PIC X.\n",
                name
            ));
        }

        // Attribute field
        if self.include_attribute {
            output.push_str(&format!(
                "               10  {}A              PIC X.\n",
                name
            ));
        }

        // Data field
        let picture = self.get_picture(field);
        output.push_str(&format!(
            "               10  {}I              PIC {}.\n",
            name, picture
        ));

        output
    }

    fn generate_output_field(&self, field: &BmsField) -> String {
        let mut output = String::new();
        let name = field.name.replace('-', "_");

        // Length field
        if self.include_length {
            output.push_str(&format!(
                "               10  {}L              PIC S9(4) COMP.\n",
                name
            ));
        }

        // Flag field
        if self.include_flag {
            output.push_str(&format!(
                "               10  {}F              PIC X.\n",
                name
            ));
        }

        // Attribute field
        if self.include_attribute {
            output.push_str(&format!(
                "               10  {}A              PIC X.\n",
                name
            ));
        }

        // Data field
        let picture = self.get_picture(field);
        output.push_str(&format!(
            "               10  {}O              PIC {}.\n",
            name, picture
        ));

        output
    }

    fn get_picture(&self, field: &BmsField) -> String {
        // Use explicit picture if provided
        if let Some(pic) = &field.picture {
            return pic.clone();
        }

        // Generate default picture based on field type and length
        if field.attributes.numeric {
            if field.length > 9 {
                format!("9({})", field.length)
            } else {
                "9".repeat(field.length)
            }
        } else if field.length > 10 {
            format!("X({})", field.length)
        } else {
            "X".repeat(field.length)
        }
    }

    /// Generate DFHBMSCA (attribute byte constants).
    pub fn generate_dfhbmsca() -> String {
        let mut output = String::new();

        output.push_str("      ******************************************************************\n");
        output.push_str("      * DFHBMSCA - BMS ATTRIBUTE CONSTANTS\n");
        output.push_str("      ******************************************************************\n");
        output.push_str("       01  DFHBMSCA.\n");
        output.push_str("           05  DFHBMPEM          PIC X VALUE X'00'.\n");
        output.push_str("           05  DFHBMPNL          PIC X VALUE X'00'.\n");
        output.push_str("           05  DFHBMASK          PIC X VALUE X'71'.\n");
        output.push_str("           05  DFHBMUNP          PIC X VALUE X'40'.\n");
        output.push_str("           05  DFHBMUNN          PIC X VALUE X'50'.\n");
        output.push_str("           05  DFHBMPRO          PIC X VALUE X'60'.\n");
        output.push_str("           05  DFHBMPRF          PIC X VALUE X'61'.\n");
        output.push_str("           05  DFHBMBRY          PIC X VALUE X'68'.\n");
        output.push_str("           05  DFHBMDAR          PIC X VALUE X'6C'.\n");
        output.push_str("           05  DFHBMFSE          PIC X VALUE X'41'.\n");
        output.push_str("           05  DFHSA             PIC X VALUE X'28'.\n");
        output.push_str("           05  DFHCOLOR          PIC X VALUE X'42'.\n");
        output.push_str("           05  DFHPS             PIC X VALUE X'43'.\n");
        output.push_str("           05  DFHHLT            PIC X VALUE X'41'.\n");
        output.push_str("           05  DFHDFCOL          PIC X VALUE X'00'.\n");
        output.push_str("           05  DFHBLUE           PIC X VALUE X'F1'.\n");
        output.push_str("           05  DFHRED            PIC X VALUE X'F2'.\n");
        output.push_str("           05  DFHPINK           PIC X VALUE X'F3'.\n");
        output.push_str("           05  DFHGREEN          PIC X VALUE X'F4'.\n");
        output.push_str("           05  DFHTURQ           PIC X VALUE X'F5'.\n");
        output.push_str("           05  DFHYELLO          PIC X VALUE X'F6'.\n");
        output.push_str("           05  DFHWHITE          PIC X VALUE X'F7'.\n");
        output.push_str("           05  DFHDFHI           PIC X VALUE X'00'.\n");
        output.push_str("           05  DFHBLINK          PIC X VALUE X'F1'.\n");
        output.push_str("           05  DFHREVRS          PIC X VALUE X'F2'.\n");
        output.push_str("           05  DFHUNDLN          PIC X VALUE X'F4'.\n");

        output
    }
}

impl Default for SymbolicMapGenerator {
    fn default() -> Self {
        Self::new()
    }
}

/// Calculate symbolic map structure size.
pub fn calculate_map_size(map: &BmsMap, include_length: bool, include_flag: bool, include_attr: bool) -> usize {
    let mut size = 12; // TIOAPFX

    for field in &map.fields {
        if !field.name.is_empty() {
            if include_length {
                size += 2; // S9(4) COMP
            }
            if include_flag {
                size += 1;
            }
            if include_attr {
                size += 1;
            }
            size += field.length;
        }
    }

    size
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::bms::parser::BmsParser;

    #[test]
    fn test_generate_symbolic_map() {
        let source = r#"
CUSTMAP  DFHMSD TYPE=MAP,LANG=COBOL
CUSTM1   DFHMDI SIZE=(24,80)
CUSTNO   DFHMDF POS=(5,15),LENGTH=8,ATTRB=(NUM,UNPROT)
CUSTNM   DFHMDF POS=(5,25),LENGTH=30,ATTRB=(PROT)
         DFHMSD TYPE=FINAL
"#;

        let mut parser = BmsParser::new();
        let mapset = parser.parse(source).unwrap();

        let generator = SymbolicMapGenerator::new();
        let copybook = generator.generate(&mapset);

        // Check structure
        assert!(copybook.contains("01  CUSTMAPI."));
        assert!(copybook.contains("05  CUSTM1I."));
        assert!(copybook.contains("CUSTNOL"));
        assert!(copybook.contains("CUSTNOI"));
        assert!(copybook.contains("01  CUSTMAPO REDEFINES CUSTMAPI."));
    }

    #[test]
    fn test_picture_generation() {
        let source = r#"
TEST     DFHMSD TYPE=MAP,LANG=COBOL
TESTM    DFHMDI SIZE=(24,80)
SHORT    DFHMDF POS=(1,1),LENGTH=5,ATTRB=(UNPROT)
LONG     DFHMDF POS=(2,1),LENGTH=50,ATTRB=(UNPROT)
NUMER    DFHMDF POS=(3,1),LENGTH=8,ATTRB=(NUM,UNPROT)
         DFHMSD TYPE=FINAL
"#;

        let mut parser = BmsParser::new();
        let mapset = parser.parse(source).unwrap();

        let generator = SymbolicMapGenerator::new();
        let copybook = generator.generate(&mapset);

        // Short alphanumeric should use XXXXX
        assert!(copybook.contains("PIC XXXXX"));
        // Long alphanumeric should use X(50)
        assert!(copybook.contains("PIC X(50)"));
        // Numeric should use 9s
        assert!(copybook.contains("PIC 99999999"));
    }

    #[test]
    fn test_dfhbmsca() {
        let dfhbmsca = SymbolicMapGenerator::generate_dfhbmsca();

        assert!(dfhbmsca.contains("DFHBMSCA"));
        assert!(dfhbmsca.contains("DFHBMASK"));
        assert!(dfhbmsca.contains("DFHBMPRO"));
        assert!(dfhbmsca.contains("DFHGREEN"));
    }

    #[test]
    fn test_map_size_calculation() {
        let source = r#"
TEST     DFHMSD TYPE=MAP,LANG=COBOL
TESTM    DFHMDI SIZE=(24,80)
FLD1     DFHMDF POS=(1,1),LENGTH=10,ATTRB=(UNPROT)
FLD2     DFHMDF POS=(2,1),LENGTH=20,ATTRB=(PROT)
         DFHMSD TYPE=FINAL
"#;

        let mut parser = BmsParser::new();
        let mapset = parser.parse(source).unwrap();
        let map = &mapset.maps[0];

        // Size = 12 (TIOAPFX) + 2 fields * (2 + 1 + 1 + length)
        // = 12 + (2 + 1 + 1 + 10) + (2 + 1 + 1 + 20)
        // = 12 + 14 + 24 = 50
        let size = calculate_map_size(map, true, true, true);
        assert_eq!(size, 50);
    }

    #[test]
    fn test_without_optional_fields() {
        let source = r#"
TEST     DFHMSD TYPE=MAP,LANG=COBOL
TESTM    DFHMDI SIZE=(24,80)
FLD1     DFHMDF POS=(1,1),LENGTH=10,ATTRB=(UNPROT)
         DFHMSD TYPE=FINAL
"#;

        let mut parser = BmsParser::new();
        let mapset = parser.parse(source).unwrap();

        let generator = SymbolicMapGenerator::new()
            .without_length()
            .without_attribute();

        let copybook = generator.generate(&mapset);

        // Should not contain length field
        assert!(!copybook.contains("FLD1L"));
        // Should not contain attribute field
        assert!(!copybook.contains("FLD1A"));
        // Should still contain data field
        assert!(copybook.contains("FLD1I"));
    }
}
