//! Token definitions for COBOL lexical analysis.
//!
//! Tokens are the fundamental units produced by the lexer. Each token
//! has a kind, span (location in source), and optional associated data.

use crate::lexer::span::Span;

/// A token produced by the lexer.
#[derive(Debug, Clone, PartialEq)]
pub struct Token {
    /// The kind of token.
    pub kind: TokenKind,
    /// Location in source code.
    pub span: Span,
}

impl Token {
    /// Create a new token.
    pub fn new(kind: TokenKind, span: Span) -> Self {
        Self { kind, span }
    }

    /// Check if this is an end-of-file token.
    pub fn is_eof(&self) -> bool {
        self.kind == TokenKind::Eof
    }

    /// Check if this token is a specific keyword.
    pub fn is_keyword(&self, kw: Keyword) -> bool {
        matches!(&self.kind, TokenKind::Keyword(k) if *k == kw)
    }
}

/// The kind of token.
#[derive(Debug, Clone, PartialEq)]
#[non_exhaustive]
pub enum TokenKind {
    // Literals
    /// Integer literal (e.g., 123)
    IntegerLiteral(i64),
    /// Decimal literal (e.g., 123.45)
    DecimalLiteral(String),
    /// String literal (e.g., "HELLO" or 'HELLO')
    StringLiteral(String),
    /// Hex literal (e.g., X"FF")
    HexLiteral(String),
    /// National string literal (e.g., N"...")
    NationalLiteral(String),

    // Identifiers and keywords
    /// User-defined identifier
    Identifier(String),
    /// Reserved keyword
    Keyword(Keyword),

    // Picture clause (special handling)
    /// Picture string (e.g., X(10), 9(5)V99)
    PictureString(String),

    // Operators
    /// + (plus or positive sign)
    Plus,
    /// - (minus or negative sign)
    Minus,
    /// * (multiply)
    Star,
    /// / (divide)
    Slash,
    /// ** (exponentiation)
    DoubleStar,
    /// = (equals)
    Equals,
    /// > (greater than)
    GreaterThan,
    /// < (less than)
    LessThan,
    /// >= (greater than or equal)
    GreaterEquals,
    /// <= (less than or equal)
    LessEquals,
    /// <> or NOT = (not equal)
    NotEquals,

    // Punctuation
    /// . (period/full stop - statement terminator)
    Period,
    /// , (comma)
    Comma,
    /// ; (semicolon)
    Semicolon,
    /// : (colon)
    Colon,
    /// ( (left parenthesis)
    LeftParen,
    /// ) (right parenthesis)
    RightParen,
    /// :: (double colon, for qualification)
    DoubleColon,

    // Reference modification
    /// ( position : length ) for reference modification is parsed as tokens

    // Special
    /// End of file
    Eof,
    /// Error token (lexer error recovery)
    Error(String),
    /// Newline (for format-sensitive parsing)
    Newline,
}

impl TokenKind {
    /// Get a human-readable description of this token kind.
    pub fn description(&self) -> &'static str {
        match self {
            TokenKind::IntegerLiteral(_) => "integer literal",
            TokenKind::DecimalLiteral(_) => "decimal literal",
            TokenKind::StringLiteral(_) => "string literal",
            TokenKind::HexLiteral(_) => "hex literal",
            TokenKind::NationalLiteral(_) => "national literal",
            TokenKind::Identifier(_) => "identifier",
            TokenKind::Keyword(_) => "keyword",
            TokenKind::PictureString(_) => "picture string",
            TokenKind::Plus => "'+'",
            TokenKind::Minus => "'-'",
            TokenKind::Star => "'*'",
            TokenKind::Slash => "'/'",
            TokenKind::DoubleStar => "'**'",
            TokenKind::Equals => "'='",
            TokenKind::GreaterThan => "'>'",
            TokenKind::LessThan => "'<'",
            TokenKind::GreaterEquals => "'>='",
            TokenKind::LessEquals => "'<='",
            TokenKind::NotEquals => "'<>'",
            TokenKind::Period => "'.'",
            TokenKind::Comma => "','",
            TokenKind::Semicolon => "';'",
            TokenKind::Colon => "':'",
            TokenKind::LeftParen => "'('",
            TokenKind::RightParen => "')'",
            TokenKind::DoubleColon => "'::'",
            TokenKind::Eof => "end of file",
            TokenKind::Error(_) => "error",
            TokenKind::Newline => "newline",
        }
    }
}

/// COBOL reserved keywords.
///
/// This enum contains all COBOL-85 reserved words plus commonly used
/// COBOL-2002 and IBM extensions.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[non_exhaustive]
#[allow(missing_docs)]
pub enum Keyword {
    // Division/Section keywords
    Identification,
    Environment,
    Data,
    Procedure,
    Division,
    Section,

    // Identification Division
    ProgramId,
    Author,
    Installation,
    DateWritten,
    DateCompiled,
    Security,

    // Environment Division
    Configuration,
    SourceComputer,
    ObjectComputer,
    SpecialNames,
    InputOutput,
    FileControl,
    Select,
    Assign,
    Organization,
    Sequential,
    Indexed,
    Relative,
    AccessMode,
    Random,
    Dynamic,
    RecordKey,
    AlternateRecordKey,
    FileStatus,

    // Data Division
    File,
    Working,
    Storage,
    Status,
    WorkingStorage,
    LocalStorage,
    Linkage,
    Fd,
    Sd,
    Pic,
    Picture,
    Value,
    Values,
    Redefines,
    Occurs,
    Times,
    // Note: Indexed is already defined in Environment Division section
    By,
    Ascending,
    Descending,
    Key,
    Depending,
    On,
    Comp,
    Comp1,
    Comp2,
    Comp3,
    Comp4,
    Comp5,
    Computational,
    Computational1,
    Computational2,
    Computational3,
    Computational4,
    Computational5,
    Binary,
    PackedDecimal,
    Display,
    Usage,
    Sign,
    Leading,
    Trailing,
    Separate,
    Character,
    Justified,
    Just,
    Right,
    Left,
    Blank,
    When,
    Zero,
    Zeros,
    Zeroes,
    Space,
    Spaces,
    HighValue,
    HighValues,
    LowValue,
    LowValues,
    Quote,
    Quotes,
    All,
    Filler,
    Renames,
    Through,
    Thru,
    Copy,
    Replacing,

    // Procedure Division
    Perform,
    Until,
    Varying,
    From,
    After,
    Move,
    To,
    Corresponding,
    Corr,
    Add,
    Subtract,
    Multiply,
    Divide,
    Compute,
    Giving,
    Rounded,
    OnSizeError,
    NotOnSizeError,
    If,
    Then,
    Else,
    EndIf,
    Evaluate,
    Also,
    Any,
    True,
    False,
    Other,
    EndEvaluate,
    GoTo,
    Go,
    Stop,
    Run,
    Exit,
    Program,
    Paragraph,
    Call,
    Using,
    Returning,
    Reference,
    Content,
    Length,
    OnException,
    NotOnException,
    OnOverflow,
    NotOnOverflow,
    Cancel,
    Chain,
    Continue,
    Initialize,
    Inspect,
    Tallying,
    For,
    Characters,
    Initial,
    Converting,
    Before,
    String,
    Delimited,
    Size,
    Into,
    Pointer,
    WithPointer,
    Overflow,
    EndString,
    Unstring,
    Count,
    Delimiter,
    EndUnstring,
    Accept,
    Date,
    Day,
    DayOfWeek,
    Time,
    Open,
    Input,
    Output,
    Io,
    Extend,
    Close,
    Read,
    Next,
    Record,
    AtEnd,
    NotAtEnd,
    InvalidKey,
    NotInvalidKey,
    EndRead,
    Write,
    Advancing,
    Page,
    Line,
    Lines,
    EndWrite,
    Rewrite,
    EndRewrite,
    Delete,
    EndDelete,
    Start,
    EndStart,
    Return,
    EndReturn,
    Sort,
    Merge,
    Release,
    Search,
    EndSearch,
    Set,
    UpBy,
    DownBy,
    Address,
    Of,
    Upon,
    NoAdvancing,

    // Conditions
    And,
    Or,
    Not,
    Is,
    Are,
    Equal,
    Greater,
    Less,
    Than,
    Numeric,
    Alphabetic,
    AlphabeticLower,
    AlphabeticUpper,
    Positive,
    Negative,
    Class,
    Omitted,

    // EXEC CICS/SQL support
    Exec,
    Cics,
    Sql,
    EndExec,

    // COBOL-2002 / IBM Extensions
    Function,
    End,
    EndProgram,
    EndPerform,
    EndCompute,
    EndAdd,
    EndSubtract,
    EndMultiply,
    EndDivide,
    EndCall,
    EndAccept,
    Remainder,
    Native,
    Standard1,
    Standard2,
    With,
    Debugging,
    Mode,
    Common,
    External,
    Global,
    CurrencySign,
    DecimalPoint,
    Comma,
    AlphabetName,
    SymbolicCharacters,
    ClassCondition,
    ConditionName,
    // Level indicators (special treatment)
    // Note: Level numbers are parsed as integers, not keywords
}

impl Keyword {
    /// Get the string representation of this keyword.
    pub fn as_str(&self) -> &'static str {
        match self {
            Keyword::Identification => "IDENTIFICATION",
            Keyword::Environment => "ENVIRONMENT",
            Keyword::Data => "DATA",
            Keyword::Procedure => "PROCEDURE",
            Keyword::Division => "DIVISION",
            Keyword::Section => "SECTION",
            Keyword::ProgramId => "PROGRAM-ID",
            Keyword::Author => "AUTHOR",
            Keyword::Installation => "INSTALLATION",
            Keyword::DateWritten => "DATE-WRITTEN",
            Keyword::DateCompiled => "DATE-COMPILED",
            Keyword::Security => "SECURITY",
            Keyword::Configuration => "CONFIGURATION",
            Keyword::SourceComputer => "SOURCE-COMPUTER",
            Keyword::ObjectComputer => "OBJECT-COMPUTER",
            Keyword::SpecialNames => "SPECIAL-NAMES",
            Keyword::InputOutput => "INPUT-OUTPUT",
            Keyword::FileControl => "FILE-CONTROL",
            Keyword::Select => "SELECT",
            Keyword::Assign => "ASSIGN",
            Keyword::Organization => "ORGANIZATION",
            Keyword::Sequential => "SEQUENTIAL",
            Keyword::Indexed => "INDEXED",
            Keyword::Relative => "RELATIVE",
            Keyword::AccessMode => "ACCESS",
            Keyword::Random => "RANDOM",
            Keyword::Dynamic => "DYNAMIC",
            Keyword::RecordKey => "RECORD",
            Keyword::AlternateRecordKey => "ALTERNATE",
            Keyword::FileStatus => "FILE",
            Keyword::File => "FILE",
            Keyword::Working => "WORKING",
            Keyword::Storage => "STORAGE",
            Keyword::Status => "STATUS",
            Keyword::WorkingStorage => "WORKING-STORAGE",
            Keyword::LocalStorage => "LOCAL-STORAGE",
            Keyword::Linkage => "LINKAGE",
            Keyword::Fd => "FD",
            Keyword::Sd => "SD",
            Keyword::Pic => "PIC",
            Keyword::Picture => "PICTURE",
            Keyword::Value => "VALUE",
            Keyword::Values => "VALUES",
            Keyword::Redefines => "REDEFINES",
            Keyword::Occurs => "OCCURS",
            Keyword::Times => "TIMES",
            Keyword::By => "BY",
            Keyword::Ascending => "ASCENDING",
            Keyword::Descending => "DESCENDING",
            Keyword::Key => "KEY",
            Keyword::Depending => "DEPENDING",
            Keyword::On => "ON",
            Keyword::Comp => "COMP",
            Keyword::Comp1 => "COMP-1",
            Keyword::Comp2 => "COMP-2",
            Keyword::Comp3 => "COMP-3",
            Keyword::Comp4 => "COMP-4",
            Keyword::Comp5 => "COMP-5",
            Keyword::Computational => "COMPUTATIONAL",
            Keyword::Computational1 => "COMPUTATIONAL-1",
            Keyword::Computational2 => "COMPUTATIONAL-2",
            Keyword::Computational3 => "COMPUTATIONAL-3",
            Keyword::Computational4 => "COMPUTATIONAL-4",
            Keyword::Computational5 => "COMPUTATIONAL-5",
            Keyword::Binary => "BINARY",
            Keyword::PackedDecimal => "PACKED-DECIMAL",
            Keyword::Display => "DISPLAY",
            Keyword::Usage => "USAGE",
            Keyword::Sign => "SIGN",
            Keyword::Leading => "LEADING",
            Keyword::Trailing => "TRAILING",
            Keyword::Separate => "SEPARATE",
            Keyword::Character => "CHARACTER",
            Keyword::Justified => "JUSTIFIED",
            Keyword::Just => "JUST",
            Keyword::Right => "RIGHT",
            Keyword::Left => "LEFT",
            Keyword::Blank => "BLANK",
            Keyword::When => "WHEN",
            Keyword::Zero => "ZERO",
            Keyword::Zeros => "ZEROS",
            Keyword::Zeroes => "ZEROES",
            Keyword::Space => "SPACE",
            Keyword::Spaces => "SPACES",
            Keyword::HighValue => "HIGH-VALUE",
            Keyword::HighValues => "HIGH-VALUES",
            Keyword::LowValue => "LOW-VALUE",
            Keyword::LowValues => "LOW-VALUES",
            Keyword::Quote => "QUOTE",
            Keyword::Quotes => "QUOTES",
            Keyword::All => "ALL",
            Keyword::Filler => "FILLER",
            Keyword::Renames => "RENAMES",
            Keyword::Through => "THROUGH",
            Keyword::Thru => "THRU",
            Keyword::Copy => "COPY",
            Keyword::Replacing => "REPLACING",
            Keyword::Perform => "PERFORM",
            Keyword::Until => "UNTIL",
            Keyword::Varying => "VARYING",
            Keyword::From => "FROM",
            Keyword::After => "AFTER",
            Keyword::Move => "MOVE",
            Keyword::To => "TO",
            Keyword::Corresponding => "CORRESPONDING",
            Keyword::Corr => "CORR",
            Keyword::Add => "ADD",
            Keyword::Subtract => "SUBTRACT",
            Keyword::Multiply => "MULTIPLY",
            Keyword::Divide => "DIVIDE",
            Keyword::Compute => "COMPUTE",
            Keyword::Giving => "GIVING",
            Keyword::Rounded => "ROUNDED",
            Keyword::OnSizeError => "SIZE",
            Keyword::NotOnSizeError => "SIZE",
            Keyword::If => "IF",
            Keyword::Then => "THEN",
            Keyword::Else => "ELSE",
            Keyword::EndIf => "END-IF",
            Keyword::Evaluate => "EVALUATE",
            Keyword::Also => "ALSO",
            Keyword::Any => "ANY",
            Keyword::True => "TRUE",
            Keyword::False => "FALSE",
            Keyword::Other => "OTHER",
            Keyword::EndEvaluate => "END-EVALUATE",
            Keyword::GoTo => "GO",
            Keyword::Go => "GO",
            Keyword::Stop => "STOP",
            Keyword::Run => "RUN",
            Keyword::Exit => "EXIT",
            Keyword::Program => "PROGRAM",
            Keyword::Paragraph => "PARAGRAPH",
            Keyword::Call => "CALL",
            Keyword::Using => "USING",
            Keyword::Returning => "RETURNING",
            Keyword::Reference => "REFERENCE",
            Keyword::Content => "CONTENT",
            Keyword::Length => "LENGTH",
            Keyword::OnException => "EXCEPTION",
            Keyword::NotOnException => "EXCEPTION",
            Keyword::OnOverflow => "OVERFLOW",
            Keyword::NotOnOverflow => "OVERFLOW",
            Keyword::Cancel => "CANCEL",
            Keyword::Chain => "CHAIN",
            Keyword::Continue => "CONTINUE",
            Keyword::Initialize => "INITIALIZE",
            Keyword::Inspect => "INSPECT",
            Keyword::Tallying => "TALLYING",
            Keyword::For => "FOR",
            Keyword::Characters => "CHARACTERS",
            Keyword::Initial => "INITIAL",
            Keyword::Converting => "CONVERTING",
            Keyword::Before => "BEFORE",
            Keyword::String => "STRING",
            Keyword::Delimited => "DELIMITED",
            Keyword::Size => "SIZE",
            Keyword::Into => "INTO",
            Keyword::Pointer => "POINTER",
            Keyword::WithPointer => "POINTER",
            Keyword::Overflow => "OVERFLOW",
            Keyword::EndString => "END-STRING",
            Keyword::Unstring => "UNSTRING",
            Keyword::Count => "COUNT",
            Keyword::Delimiter => "DELIMITER",
            Keyword::EndUnstring => "END-UNSTRING",
            Keyword::Accept => "ACCEPT",
            Keyword::Date => "DATE",
            Keyword::Day => "DAY",
            Keyword::DayOfWeek => "DAY-OF-WEEK",
            Keyword::Time => "TIME",
            Keyword::Open => "OPEN",
            Keyword::Input => "INPUT",
            Keyword::Output => "OUTPUT",
            Keyword::Io => "I-O",
            Keyword::Extend => "EXTEND",
            Keyword::Close => "CLOSE",
            Keyword::Read => "READ",
            Keyword::Next => "NEXT",
            Keyword::Record => "RECORD",
            Keyword::AtEnd => "END",
            Keyword::NotAtEnd => "END",
            Keyword::InvalidKey => "INVALID",
            Keyword::NotInvalidKey => "INVALID",
            Keyword::EndRead => "END-READ",
            Keyword::Write => "WRITE",
            Keyword::Advancing => "ADVANCING",
            Keyword::Page => "PAGE",
            Keyword::Line => "LINE",
            Keyword::Lines => "LINES",
            Keyword::EndWrite => "END-WRITE",
            Keyword::Rewrite => "REWRITE",
            Keyword::EndRewrite => "END-REWRITE",
            Keyword::Delete => "DELETE",
            Keyword::EndDelete => "END-DELETE",
            Keyword::Start => "START",
            Keyword::EndStart => "END-START",
            Keyword::Return => "RETURN",
            Keyword::EndReturn => "END-RETURN",
            Keyword::Sort => "SORT",
            Keyword::Merge => "MERGE",
            Keyword::Release => "RELEASE",
            Keyword::Search => "SEARCH",
            Keyword::EndSearch => "END-SEARCH",
            Keyword::Set => "SET",
            Keyword::UpBy => "UP",
            Keyword::DownBy => "DOWN",
            Keyword::Address => "ADDRESS",
            Keyword::Of => "OF",
            Keyword::Upon => "UPON",
            Keyword::NoAdvancing => "NO",
            Keyword::And => "AND",
            Keyword::Or => "OR",
            Keyword::Not => "NOT",
            Keyword::Is => "IS",
            Keyword::Are => "ARE",
            Keyword::Equal => "EQUAL",
            Keyword::Greater => "GREATER",
            Keyword::Less => "LESS",
            Keyword::Than => "THAN",
            Keyword::Numeric => "NUMERIC",
            Keyword::Alphabetic => "ALPHABETIC",
            Keyword::AlphabeticLower => "ALPHABETIC-LOWER",
            Keyword::AlphabeticUpper => "ALPHABETIC-UPPER",
            Keyword::Positive => "POSITIVE",
            Keyword::Negative => "NEGATIVE",
            Keyword::Class => "CLASS",
            Keyword::Omitted => "OMITTED",
            Keyword::Function => "FUNCTION",
            Keyword::Exec => "EXEC",
            Keyword::Cics => "CICS",
            Keyword::Sql => "SQL",
            Keyword::EndExec => "END-EXEC",
            Keyword::End => "END",
            Keyword::EndProgram => "END-PROGRAM",
            Keyword::EndPerform => "END-PERFORM",
            Keyword::EndCompute => "END-COMPUTE",
            Keyword::EndAdd => "END-ADD",
            Keyword::EndSubtract => "END-SUBTRACT",
            Keyword::EndMultiply => "END-MULTIPLY",
            Keyword::EndDivide => "END-DIVIDE",
            Keyword::EndCall => "END-CALL",
            Keyword::EndAccept => "END-ACCEPT",
            Keyword::Remainder => "REMAINDER",
            Keyword::Native => "NATIVE",
            Keyword::Standard1 => "STANDARD-1",
            Keyword::Standard2 => "STANDARD-2",
            Keyword::With => "WITH",
            Keyword::Debugging => "DEBUGGING",
            Keyword::Mode => "MODE",
            Keyword::Common => "COMMON",
            Keyword::External => "EXTERNAL",
            Keyword::Global => "GLOBAL",
            Keyword::CurrencySign => "CURRENCY",
            Keyword::DecimalPoint => "DECIMAL-POINT",
            Keyword::Comma => "COMMA",
            Keyword::AlphabetName => "ALPHABET",
            Keyword::SymbolicCharacters => "SYMBOLIC",
            Keyword::ClassCondition => "CLASS",
            Keyword::ConditionName => "CONDITION",
        }
    }
}
